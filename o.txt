include <omp.h>
#include <stdio.h>


int main(){
	int array[5]={5, 10, 15, 20, 25};
int count;

	#pragma omp parallel for reduction(+:count)
for(int i=0;i<5;i++)
{
	if(array[i]>10)
	{
		count += 1;
	}
}

printf("count = %d",count);

return 0;
}




#include <omp.h>
#include <stdio.h>

int main() {


	

	int array[20];
	#pragma omp parallel 
	for(int i = 0 ;i < 20 ;i++) {
		
		 array[i]= i;
	}
	
	#pragma omp master
	{
			for(int i = 0 ;i < 20 ;i++) {
		printf("array[%d]= %d \n",i,array[i]);
	}
	}
	
	return 0;
}



#include <stdio.h>
#include <omp.h>



int main() {
    int A[5][5];
    int i;
    int j;

  
    #pragma omp parallel for private(j)
    for (i = 0; i < 5; i++) {
    	 for (j= 0; j < 5; j++){
    	 	
    	 	int myid = omp_get_thread_num();
    	 	A[i][j] = i + j;
    	 	
    	 	printf("thread id = %d , A[%d][%d]  = %d \n",myid,i,j,A[i][j]);
    	 	
		 }
      
    }
    
     #pragma omp master
    {
        printf("\nFinal 5x5 Matrix (printed by master thread):\n");
        for (i = 0; i < 5 ;i++) {
            for (j = 0; j < 5; j++) {
                printf("%d ", A[i][j]);
            }
            printf("\n");
        }
    }

   

    return 0;
}








#include <omp.h>
#include <stdio.h>

#define N 4

int main() {

	int A[4][4],B[N][N],C[N][N];
	int i,j,k;
	
	#pragma omp master
	{
		for(i=0;i<N;i++){
			for(j=0;j<N;j++)
			{
				A[i][j]=i+j;
				B[i][j]=i*j;
			}
		}
	}
	
	
	#pragma omp parallel for private(j,k) shared(A,B,C)
	
		for(i=0;i<N;i++)
		{
			for(j=0;j<N;j++)
			{
				int sum=0;
				for(k=0;k<N;k++)
				{
					sum+=A[i][k] *B[k][j];
				}
					C[i][j]=sum;
			int myid = omp_get_thread_num();
            printf("Thread %d computed C[%d][%d] = %d\n", myid, i, j, C[i][j]);
			}
	
		}
		
	
	
	#pragma omp master
	{
		for(i=0;i<N;i++)
		{
			for(j=0;j<N;j++){
				
				printf("%4d ", C[i][j]);
			}
			printf("\n");
		}
	}
	
	return 0;
}


#include <omp.h>
#include <stdio.h>

#define N 8

int main(){
	int i,j;
	int prev[N],curr[N];
	
	prev[0]=1;
	printf("Row 0: 1\n");
	
	for(i=1;i<N;i++)
	{
		curr[0]=1;
		curr[i]=1;
		
		#pragma omp parallel for private(j)
		for(j=1;j<i;j++){
			curr[j]=prev[j-1]+prev[j];
			int myid = omp_get_thread_num();
			printf("Thread %d computed curr[%d] = %d\n", myid, j, curr[j]);
        }
		
		
	
		
			printf("Row %d: ",i);
			for(j=0;j<=i;j++){
				printf("%d" ,curr[j]);
				
			}	
		printf("\n\n");
		
	
	for(j =0;j<=i;j++){
		
		 prev[j] = curr[j];
	}
	

}
	return 0;
}







#include <stdio.h>
#include <omp.h>

long N = 100000000;
double dx;

int main()
{
	int i;
	double x, pi, sum = 0.0;
	double start_time, run_time;

	dx = 1.0 / (double)N;

	start_time = omp_get_wtime();

	for (i = 0; i < N; i++) {
		x = (i + 0.5) * dx;
		sum += 4.0 / (1.0 + x * x);
	}

	pi = sum * dx;

	run_time = omp_get_wtime() - start_time;
	printf("\n pi with %ld steps is %lf in %lf seconds\n ", N, pi, run_time);
}